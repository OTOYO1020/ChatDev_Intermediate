Read the dimensions of the maze, H and W, from standard input. Read the maze grid S, which consists of H strings of length W, containing characters '.' and '#'. Initialize a variable 'max_moves' to store the maximum number of moves Aoki has to make. Create a function 'bfs(start, goal)' that implements Breadth-First Search to find the shortest path from the starting square to the goal square. Iterate through all pairs of road squares (i.e., positions in S where 'S[i][j]' is '.') to consider each as a potential starting and goal square. For each pair of road squares, call 'bfs(start, goal)' to determine the number of moves required to reach the goal from the start. Update 'max_moves' with the maximum value returned by 'bfs(start, goal)' for all pairs. After evaluating all pairs, print the value of 'max_moves' as the final output.