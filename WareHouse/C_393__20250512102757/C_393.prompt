Define a function 'min_edges_to_remove(N: int, M: int, edges: List[Tuple[int, int]]) -> int' to encapsulate the logic for calculating the minimum number of edges to remove. Parse the input to extract the number of vertices 'N' and edges 'M', and the list of edges 'edges' as tuples of integers '(u_i, v_i)'. Initialize a data structure (e.g., a dictionary or a set) to track the unique edges and self-loops. Iterate through the list of edges and for each edge '(u_i, v_i)', check if it creates a self-loop or is a multi-edge. If an edge is a self-loop (i.e., 'u_i == v_i'), increment a counter for self-loops. If an edge '(u_i, v_i)' is already in the data structure, increment a counter for multi-edges. After processing all edges, calculate the total number of edges to remove as the sum of self-loops and the count of multi-edges. Return the total count of edges to remove from the function 'min_edges_to_remove'. Ensure that the function handles edge cases, such as when 'M' is zero or when all edges are valid. Output the result of the function in the format of a single integer representing the minimum number of edges to remove.