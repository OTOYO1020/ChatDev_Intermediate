Read the integer values N and M from standard input, where N represents the size of the grid and M represents the distance squared for movement. Initialize a 2D list 'reachable' of size N x N with all values set to 'False', which will track whether each square (i, j) is reachable. Calculate the distance 'd = sqrt(M}' and determine the integer values of 'dx' and 'dy' such that 'dx^2 + dy^2 = M'. For each square (i, j) in the grid, check if it can be reached from the starting position (1, 1) using the calculated distances:\n   - Loop through possible values of 'dx' and 'dy' within the grid boundaries.\n   - If the square (i + dx, j + dy) is within bounds, mark 'reachable[i][j]' as 'True'. Implement a breadth-first search (BFS) or depth-first search (DFS) algorithm starting from (1, 1) to explore all reachable squares:\n   - Use a queue or stack to manage the exploration of squares.\n   - For each square, attempt to move to all valid squares based on the calculated distances. Count the number of operations required to reach each square (i, j) from (1, 1) and store the results in a 2D list 'min_operations'. For each square (i, j), if it is reachable, update 'min_operations[i][j]' with the minimum number of moves taken to reach that square. Print the 'reachable' grid indicating which squares can be reached. Print the 'min_operations' grid showing the minimum number of operations required to reach each square. Ensure that the output format is consistent with the problem requirements, displaying both the reachability and the operation counts clearly.