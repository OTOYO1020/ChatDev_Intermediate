Input reception and initialization: Receive integers N and M from standard input, read the following M constraints (X_i, Y_i, Z_i) and store them in the constraint list constraints. This will obtain the information that each condition A[X_i] + A[Y_i] + Z_i is even. Condition parity conversion: Since the value of each card A_i is 1 or 2, treat all cards as 0,1 parity information (even/odd) instead of 1 (odd), 2 (even). In this case, the condition is converted to A[X_i] ⊕ A[Y_i] ≡ Z_i mod 2 (⊕ is XOR). Constraint graph construction: For the N vertex nodes, construct an undirected graph with constraints according to the conditions (X_i, Y_i, Z_i). Each edge is treated as an 'XOR-constrained edge (the even-odd difference between X and Y is the same as the even-odd of Z_i)'. Introducing a Union-Find structure (2-SAT-like structure): To satisfy the constraints, initialize a Union-Find structure that manages the connected components (groups whose values ​​can be guessed under the same constraints) to which each vertex belongs. Construct it with Union by XOR parity so that constraints with XOR can be handled. Grouping by constraint propagation: Apply all constraints (X_i, Y_i, Z_i) to Union-Find and perform grouping. In this case, it is guaranteed that the conditions are consistent, so no inconsistency check is necessary. Minimizing the required information acquisition (cost calculation): For each connected component, since all other cards can be guessed by investigating one card, find the number of connected components and store it as the minimum cost in the variable min_cost. Output processing: Output the calculated min_cost as an integer on one line. This gives you the cost required to ensure that you hit all of your cards.