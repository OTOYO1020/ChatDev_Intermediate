Define a function 'min_moves(r1: int, c1: int, r2: int, c2: int) -> int' to calculate the minimum number of moves from the starting position (r1, c1) to the target position (r2, c2). Implement input handling to read four integers r1, c1, r2, c2 from standard input. Check if the starting position (r1, c1) is the same as the target position (r2, c2). If they are the same, return 0 as the minimum moves. Implement the logic to determine if the target position can be reached in one move based on the movement rules provided (using the conditions for a single move). If the target cannot be reached in one move, implement a breadth-first search (BFS) algorithm to explore possible moves from (r1, c1) to (r2, c2). In the BFS, maintain a queue to track positions and the number of moves taken to reach each position. Implement the movement rules in the BFS to generate valid next positions based on the conditions given (a + b = c + d, a - b = c - d, |a - c| + |b - d| <= 3). Ensure that positions are not revisited by maintaining a set of visited positions to avoid infinite loops. Return the number of moves taken to reach (r2, c2) once it is dequeued from the BFS queue. Output the result as an integer representing the minimum number of moves needed to reach the target position.