Parse the input to read the number of vertices N, the edges A_i and B_i, and the sequence of integers C. This will involve reading the input format which includes N followed by N-1 pairs of integers for the edges and then N integers for the sequence C. Construct the tree using an adjacency list representation based on the edges provided. This will involve creating a dictionary or list to hold the connections between vertices. Implement a function 'calculate_distance' that computes the distance d(a, b) between any two vertices a and b using Depth First Search (DFS) or Breadth First Search (BFS). Implement the function 'f(x)' that calculates the sum f(x) = sum(C[i] * d(x, i)) for all vertices i from 1 to N. Iterate through all vertices from 1 to N and compute f(v) for each vertex v using the previously defined function 'f(x)'. Keep track of the minimum value of f(v) encountered during the iteration and the corresponding vertex v that produces this minimum value. Ensure that the implementation handles the constraints efficiently, particularly the upper limit of N being 100,000, to avoid time limit exceeded errors. Optimize the distance calculation to avoid recalculating distances for every vertex by using properties of trees, such as reusing previously computed distances. Test the implementation with various edge cases, including the smallest and largest possible trees, to ensure correctness and performance. Output the minimum value of f(v) found and the corresponding vertex v that achieves this minimum, ensuring the output format is correct.